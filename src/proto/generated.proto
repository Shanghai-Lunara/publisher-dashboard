/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.nevercase.publisher.pkg.types;

// Package-wide variables from generator "generated".
option go_package = "types";

message CompleteStepRequest {
  optional string namespace = 1;

  optional string groupName = 2;

  optional string runnerName = 3;

  optional Step step = 4;
}

message CompleteStepResponse {
}

message Group {
  repeated Task tasks = 1;

  repeated RunnerInfo runners = 2;
}

message ListGroupNameRequest {
  optional string namespace = 1;
}

message ListGroupNameResponse {
  repeated string items = 1;
}

message ListNamespaceRequest {
}

message ListNamespaceResponse {
  repeated string items = 1;
}

message ListRunnerRequest {
  optional string namespace = 1;

  optional string groupName = 2;
}

message ListRunnerResponse {
  repeated RunnerInfo runners = 1;
}

message ListTaskRequest {
  optional string namespace = 1;

  optional string groupName = 2;

  optional int32 page = 3;

  optional int32 length = 4;
}

message ListTaskResponse {
  repeated Task tasks = 1;
}

// +Protocol
// LogStreamRequest was the string which was transferred from the abstract Runner when the Runner was running a step.
// And it would also be sent from the Scheduler to each web dashboard for showing and watching
message LogStreamRequest {
  optional string namespace = 1;

  optional string groupName = 2;

  optional string runnerName = 3;

  optional string stepName = 4;

  optional string output = 5;
}

message LogStreamResponse {
}

message PingRequest {
}

message PongResponse {
}

message RegisterRunnerRequest {
  optional RunnerInfo runnerInfo = 1;
}

message RegisterRunnerResponse {
}

// +Protocol
// Request was the context which would be sent from the web dashboard or an abstract Runner
message Request {
  optional Type type = 1;

  optional bytes data = 2;
}

// +Protocol
// Response was the context which would be sent from the Scheduler.
message Response {
  optional int32 code = 1;

  optional string message = 2;

  optional Type type = 3;

  optional bytes data = 4;
}

message Result {
  repeated string items = 1;
}

message RunStepRequest {
  optional string namespace = 1;

  optional string groupName = 2;

  optional string runnerName = 3;

  optional Step step = 4;
}

message RunStepResponse {
}

// +Protocol
// RunnerInfo was the full information about a Runner, it would be sent from each remote abstract Runner.
message RunnerInfo {
  optional string name = 1;

  optional string hostname = 2;

  optional string namespace = 3;

  optional string groupName = 4;

  optional string runnerType = 5;

  repeated Step steps = 6;
}

message Step {
  optional int32 id = 1;

  // Name was the name of a Step which must be unique
  optional string name = 2;

  // The phase of a Step is a simple, high-level summary of where the Step is in its lifecycle.
  optional string status = 3;

  // Policy was the StepPolicy of the Step which could control the Runner
  optional string policy = 4;

  // Envs were the environment values which would be used by the called shell script.
  // Usually, they would include some base configuration
  map<string, string> envs = 5;

  // Output was the stdout from the executing shell commands
  repeated string output = 6;

  // UploadFiles were the map of the files which would be uploaded to the remote ftp server by the Step Run().
  repeated UploadFile uploadFiles = 7;

  // WriteFiles were map of the files which would be written to the remote ftp server by the Step Run().
  repeated WriteFile writeFiles = 8;

  // Messages were the human readable message indicating details about all the conditions in a Step's lifecycle.
  repeated string messages = 9;

  // RunnerName was the name of a Runner (the Runner which has been called to run this Step)
  optional string runnerName = 10;
}

message Task {
  optional int32 id = 1;

  map<string, RunnerInfo> runners = 2;
}

// +Protocol
// Type
message Type {
  optional string body = 1;

  optional string serviceApi = 2;
}

message UpdateStepRequest {
  optional string namespace = 1;

  optional string groupName = 2;

  optional string runnerName = 3;

  optional Step step = 4;
}

message UpdateStepResponse {
}

message UploadFile {
  // SourceFile was the absolute path about the file which has been marked to be uploaded later.
  optional string sourceFile = 1;

  // TargetPath was the target directory, it may be needed to be created before uploading the SourceFile
  optional string targetPath = 2;

  // TargetFile was the relative path about the file which would be created in the ftp server.
  optional string targetFile = 3;
}

message WriteFile {
  // Content was the context of the file which needed to be written to the remote ftp server.
  optional bytes content = 1;

  // TargetFile was the relative path about the file which would be created in the ftp server.
  optional string targetFile = 2;
}


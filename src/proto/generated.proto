/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.nevercase.publisher.pkg.types;

// Package-wide variables from generator "generated".
option go_package = "types";

message CompleteStepRequest {
  optional string namespace = 1;

  optional string groupName = 2;

  optional string runnerName = 3;

  optional Step step = 4;
}

message CompleteStepResponse {
}

message Group {
  repeated RunnerInfo runners = 2;
}

message ListGroupNameRequest {
  optional string namespace = 1;
}

message ListGroupNameResponse {
  repeated string items = 1;
}

message ListNamespaceRequest {
}

message ListNamespaceResponse {
  repeated string items = 1;
}

// ListRecordsRequest
message ListRecordsRequest {
  optional string namespace = 1;

  optional string groupName = 2;

  optional string runnerName = 3;

  // page specifies the offset of the first row to return
  optional int32 page = 4;

  optional int32 length = 5;

  // IsVersion specifies the filter condition in sql where
  optional int32 isVersion = 6;
}

// ListRecordsResponse
message ListRecordsResponse {
  optional ListRecordsRequest namespace = 1;

  repeated Record records = 2;

  optional int32 recordNumber = 3;
}

message ListRunnerRequest {
  optional string namespace = 1;

  optional string groupName = 2;
}

message ListRunnerResponse {
  repeated RunnerInfo runners = 1;
}

// +Protocol
// LogStreamRequest was the string which was transferred from the abstract Runner when the Runner was running a step.
// And it would also be sent from the Scheduler to each web dashboard for showing and watching
message LogStreamRequest {
  optional string namespace = 1;

  optional string groupName = 2;

  optional string runnerName = 3;

  optional string stepName = 4;

  optional string output = 5;
}

message LogStreamResponse {
}

message PingRequest {
}

message PongResponse {
}

message Record {
  optional int32 id = 1;

  optional string namespace = 2;

  optional string groupName = 3;

  optional string runnerName = 4;

  optional bytes stepInfo = 5;

  optional int32 stepType = 8;

  optional int32 createdTM = 7;
}

message RegisterRunnerRequest {
  optional RunnerInfo runnerInfo = 1;
}

message RegisterRunnerResponse {
}

// +Protocol
// Request was the context which would be sent from the web dashboard or an abstract Runner
message Request {
  optional Type type = 1;

  optional bytes data = 2;
}

// +Protocol
// Response was the context which would be sent from the Scheduler.
message Response {
  optional int32 code = 1;

  optional string message = 2;

  optional Type type = 3;

  optional bytes data = 4;
}

message Result {
  repeated string items = 1;
}

message RunStepRequest {
  optional string namespace = 1;

  optional string groupName = 2;

  optional string runnerName = 3;

  optional Step step = 4;
}

message RunStepResponse {
}

// +Protocol
// RunnerInfo was the full information about a Runner, it would be sent from each remote abstract Runner.
message RunnerInfo {
  optional string name = 1;

  optional string hostname = 2;

  optional string namespace = 3;

  optional string groupName = 4;

  optional string runnerType = 5;

  repeated Step steps = 6;
}

message Step {
  optional int32 id = 1;

  // Name was the name of a Step which must be unique
  optional string name = 2;

  // The phase of a Step is a simple, high-level summary of where the Step is in its lifecycle.
  optional string status = 3;

  // Policy was the StepPolicy of the Step which could control the Runner
  optional string policy = 4;

  // Available determines whether the Step was available, if the value was disable that means the current
  // step should be skipped instead of running.
  optional string available = 5;

  // Envs were the environment values which would be used by the called shell script.
  // Usually, they would include some base configuration
  map<string, string> envs = 6;

  // Output was the stdout from the executing shell commands
  repeated string output = 7;

  // UploadFiles were the map of the files which would be uploaded to the remote ftp server by the Step Run().
  repeated UploadFile uploadFiles = 8;

  // WriteFiles were map of the files which would be written to the remote ftp server by the Step Run().
  repeated WriteFile writeFiles = 9;

  // Messages were the human readable message indicating details about all the conditions in a Step's lifecycle.
  repeated string messages = 10;

  // RunnerName was the name of a Runner (the Runner which has been called to run this Step)
  optional string runnerName = 11;

  // DurationInMS was the total used time during the whole step
  optional int32 durationInMs = 12;

  // Remarks were the extra info after running the Step
  repeated string remarks = 13;

  // SharingData was the map which would be working for sharing data between the different Runners.
  map<string, string> sharingData = 14;

  // SharingSetting determine whether the Step needing collection different SharingData
  optional bool sharingSetting = 15;
}

// +Protocol
// Type
message Type {
  optional string body = 1;

  optional string serviceApi = 2;
}

message UpdateStepRequest {
  optional string namespace = 1;

  optional string groupName = 2;

  optional string runnerName = 3;

  optional Step step = 4;
}

message UpdateStepResponse {
}

message UploadFile {
  // SourceFile was the absolute path about the file which has been marked to be uploaded later.
  optional string sourceFile = 1;

  // TargetPath was the target directory, it may be needed to be created before uploading the SourceFile
  optional string targetPath = 2;

  // TargetFile was the relative path about the file which would be created in the ftp server.
  optional string targetFile = 3;
}

message WriteFile {
  // Content was the context of the file which needed to be written to the remote ftp server.
  optional bytes content = 1;

  // TargetFile was the relative path about the file which would be created in the ftp server.
  optional string targetFile = 2;
}

